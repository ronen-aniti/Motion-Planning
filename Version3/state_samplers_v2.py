from bounds import Bounds
from environment import Environment
from local_position import LocalPosition
import matplotlib.pyplot as plt
import numpy as np
from start_goal_pair import StartGoalPair
from state import State
from state_collection import StateCollection
from typing import List


from matplotlib.cm import ScalarMappable
from matplotlib.colors import Normalize
from matplotlib.patches import Circle
import matplotlib.patches as patches
import matplotlib.pyplot as plt

import pdb


class Planner:
	def __init__(self, environment: Environment, start_state: State, goal_state: State):
		self._state_sequence = None # The solution of the planner's search routine, provided as a list or, if a solution can't be found, as the None type. 
		self._search_space = None # A data structure generated by the planning algorithm to represent the entire state space, including its connectivity. 
		self._start_state = start_state
		self._goal_state = goal_state
		self._environment = environment

	@property
	def state_sequence(self):
		return self._state_sequence

	@property
	def search_space(self):
		return self._search_space

	@property
	def start_state(self):
		return self._start_state

	@property
	def goal_state(self):
		return self._goal_state


class RapidlyExploringRandomTree(Planner):
	def __init__(self, environment: Environment, start_state: State, goal_state: State):
		super().__init__(environment, start_state, goal_state)

		self._environment = environment 
		self._start_state = start_state
		self._goal_state = goal_state
		self._middle_states = []
		self._state_space = self._search(10)
		
	def _determine_step_size_of_tree(self) -> float:
		step_size_of_tree = self._environment.obstacles.safety # experiment with this variable
		return step_size_of_tree

	def _determine_maximum_number_of_iterations(self) -> float:
		maximum_number_of_iterations = 3000 # Experiment with this number. Maybe make it a function of the distance between the start and goal states.
		return maximum_number_of_iterations

	def _take_a_random_sample_state(self, target_altitude) -> State:
		north = np.random.uniform(low=self._environment.north_bounds.minimum, high=self._environment.north_bounds.maximum)
		east = np.random.uniform(low=self._environment.east_bounds.minimum, high=self._environment.east_bounds.maximum)
		down = target_altitude
		local_position_of_random_sample = LocalPosition(north, east, down)
		the_random_sample_state = State(self._environment, self._goal_state.local_position, local_position_of_random_sample)

		return the_random_sample_state

	def _return_the_nearest_neighbor_state(self, valid_states, the_random_sample_state) -> State:
		distance = np.inf
		the_nearest_neighbor_state = None
		for index, state in enumerate(valid_states):
			test_distance = np.linalg.norm(state.position_in_3d - the_random_sample_state.position_in_3d)
			if test_distance < distance:
				distance = test_distance
				the_nearest_neighbor_state = valid_states[index]

		return the_nearest_neighbor_state

	def _determine_resolution_of_collision_detector(self) -> float:
		resolution_of_collision_detector = 5 # meters
		return resolution_of_collision_detector

	def _plot_solution(self):
		pass

	def _search(self, target_altitude) -> StateCollection:
		maximum_number_of_iterations = self._determine_maximum_number_of_iterations()
		step_size_of_tree = self._determine_step_size_of_tree()
		resolution_of_collision_detector = self._determine_resolution_of_collision_detector()
		current_state = self._start_state
		valid_states = [current_state]
		current_iteration = 0
		goal_is_found = False
		while current_state.distance_to_goal > step_size_of_tree and current_iteration < maximum_number_of_iterations:
			the_random_sample_state = self._take_a_random_sample_state(target_altitude)
			the_nearest_neighbor_state = self._return_the_nearest_neighbor_state(valid_states, the_random_sample_state)
			the_vector_from_neighbor_to_random_sample = the_random_sample_state.position_in_3d - the_nearest_neighbor_state.position_in_3d
			length_of_the_vector_in_meters = np.linalg.norm(the_vector_from_neighbor_to_random_sample) 
			the_unit_vector = the_vector_from_neighbor_to_random_sample / length_of_the_vector_in_meters
			for current_distance_traversed in np.arange(resolution_of_collision_detector, step_size_of_tree, resolution_of_collision_detector):
				local_position_of_test_state_along_vector_step = the_nearest_neighbor_state.position_in_3d + current_distance_traversed * the_unit_vector
				local_position_of_test_state_along_vector_step = LocalPosition(
					local_position_of_test_state_along_vector_step[0], 
					local_position_of_test_state_along_vector_step[1], 
					local_position_of_test_state_along_vector_step[2])
				state_to_test = State(self._environment, self._goal_state.local_position, local_position_of_test_state_along_vector_step, parent_state=the_nearest_neighbor_state)
				test_state_is_in_collision = self._environment.state_collides_with_obstacle(state_to_test)
				if test_state_is_in_collision:
					break
				if state_to_test.distance_to_goal <= step_size_of_tree:
					goal_is_found = True
					print('path is found')
					current_state = state_to_test
					break
				current_state = state_to_test
			valid_states.append(current_state)
			current_iteration += 1

		fig, ax = plt.subplots()
		ax.set_xlabel("North")
		ax.set_ylabel("East")
		color_map_of_plot = plt.get_cmap('coolwarm')
		list_of_obstacle_heights = [obstacle.height for obstacle in self._environment.obstacles.list]
		normalization_of_obstacle_heights = Normalize(vmin=min(list_of_obstacle_heights), vmax=max(list_of_obstacle_heights))
		scalar_mappable = ScalarMappable(norm=normalization_of_obstacle_heights, cmap=color_map_of_plot)
		scalar_mappable.set_array([])
		for obstacle in self._environment.obstacles.list:
			obstacle_color = color_map_of_plot(normalization_of_obstacle_heights(obstacle.height))
			obstacle_as_a_circle_patch = patches.Circle((obstacle.local_position.north, obstacle.local_position.east), obstacle.safety, color=obstacle_color, alpha=0.3)
			ax.add_patch(obstacle_as_a_circle_patch)
			ax.text(obstacle.local_position.north, obstacle.local_position.east, f"{float(obstacle.height):.1f}", fontsize=8)
		#ax.scatter(self.goal_state.local_position.north, self.goal_state.local_position.east, c='red', s=30, marker='x', label='Goal')
		#ax.legend()
		color_bar = plt.colorbar(scalar_mappable, ax=ax)
		color_bar.set_label("Altitude (m)")


		for state in valid_states[1:]:
			plt.arrow(state.parent_state.local_position.north, 
				state.parent_state.local_position.east,state.local_position.north - state.parent_state.local_position.north,
				state.local_position.east - state.parent_state.local_position.east,
				head_width=2, head_length=2, length_includes_head=True)
		
		plt.scatter(self._start_state.local_position.north, self._start_state.local_position.east, color='red', marker='o')
		plt.scatter(self._goal_state.local_position.north, self._goal_state.local_position.east, color='red', marker='x') 
		ax.set_xlim(self._environment.north_bounds.minimum, self._environment.north_bounds.maximum)
		ax.set_ylim(self._environment.east_bounds.minimum, self._environment.east_bounds.maximum)
		plt.show()
		
		pdb.set_trace()
		if goal_is_found:
			goal_state = current_state
			while current_state.parent_state != None:
				state_sequence.append(current_state)
				current_state = current_state.parent_state
				state_sequence = state_sequence[::-1]
				state_sequence = StateCollection(self._start_state, state_sequence, self._goal_state)
				self._plot_solution()
			return state_sequence
		else:
			print("The goal has not been found.")
			self._plot_solution()
			return None







	def visualize(self):
		pass

	@property
	def state_space(self):
		return self._search_space

class LocalPositionVector:
	def __init__(self, north_component, east_component, down_component):
		self._north_component = north_component  
		self._east_component = east_component
		self._down_component = down_component 
	
	@property
	def north_component(self):
		return self._north_component

	@property
	def east_component(self):
		return self._east_component

	@property
	def down_component(self):
		return self._down_component

class ProbabilisticRoadmap(Planner):
	def visualize(self):
		pass

class PotentialField(Planner):
	def visualize(self):
		pass

class Grid(Planner):
	def visualize(self):
		pass

class Voronoi(Planner):
	def visualize(self):
		pass

class MedialAxis(Planner):
	def visualize(self):
		pass

class Voxel(Planner):
	def visualize(self):
		pass

"""
Each planner will return a sequence of states from start to goal based on some specific algorithm. 
All planners will return a sequence of states from start to goal. If no goal can be found, then 
the algorithm will retry put the drone in a hover state. 
 
"""